// Copyright (C) 2020 Julian Blaauboer

use crate::unification::unify;
use crate::Term;
use std::collections::HashMap;
use std::collections::VecDeque;

#[derive(Debug, Clone)]
/// Generator for unique variables.
/// Variables generated by the **same generator instance** will not collide with each other.
/// The variables generated by this generator follow the pattern: _G0, _G1, _G2 etc.
struct VariableGenerator {
    /// State of the generator, this is the postfix of the next generated variable.
    num: usize,
}

impl VariableGenerator {
    /// Create a new generator.
    pub fn new() -> VariableGenerator {
        VariableGenerator { num: 0 }
    }
}

impl Iterator for VariableGenerator {
    type Item = String;
    /// Generate the next unique variable.
    fn next(&mut self) -> Option<String> {
        let item = format!("_G{}", self.num);
        self.num += 1;
        Some(item)
    }
}

/// Replace all variables in a term with new ones to avoid collisions.
fn replace_variables<T>(
    term: &mut Term,
    generator: &mut T,
    replacements: &mut HashMap<String, String>,
) where
    T: Iterator<Item = String>,
{
    match term {
        Term::Variable(name) => {
            // If it is already bound to a replacement, use that replacement
            if let Some(replacement) = replacements.get(name) {
                *name = replacement.to_string();
            } else {
                let new = generator
                    .next()
                    .expect("Unable to generate unique variable name");
                replacements.insert(name.clone(), new.clone());
                *name = new;
            }
        }
        // Replace recursively
        Term::Compound(_, args) => {
            for arg in args {
                replace_variables(arg, generator, replacements);
            }
        }
        _ => (),
    };
}

#[derive(Debug, Clone)]
/// A clause is a rule or a fact.
pub struct Clause(Term, Vec<Term>);

#[derive(Debug, Clone)]
/// An universe contains all the clauses which make up the database.
pub struct Universe {
    /// All the clauses (both facts and rules) in a program/universe.
    clauses: Vec<Clause>,
}

#[derive(Debug)]
/// QueryMatches is an iterator that returns all matches with the query from a iterator of queries.
pub struct QueryMatches<'a, 'b, T>
where
    T: Iterator<Item = &'a Clause>,
{
    iter: T,
    query: Term,
    generator: &'b mut VariableGenerator,
    instantiations: &'a HashMap<String, Term>,
}
#[derive(Debug)]
/// QueryResult
pub struct QueryResult<'a> {
    universe: &'a Universe,
    generator: VariableGenerator,
    stack: VecDeque<(Vec<Term>, HashMap<String, Term>)>,
    cut_markers: Vec<usize>,
}

impl Universe {
    /// Create a new universe.
    pub fn new() -> Universe {
        Universe {
            clauses: Vec::new(),
        }
    }

    /// Add a new fact to the universe.
    pub fn add_fact(&mut self, term: Term) {
        self.clauses.push(Clause(term, Vec::new()));
    }

    /// Add a new rule to the universe.
    pub fn add_rule(&mut self, term: Term, vec: Vec<Term>) {
        self.clauses.push(Clause(term, vec));
    }

    /// Query the universe.
    pub fn query(&mut self, queries: Vec<Term>) -> QueryResult {
        QueryResult {
            universe: self,
            generator: VariableGenerator::new(),
            stack: VecDeque::from(vec![(queries, HashMap::new())]),
            cut_markers: Vec::new(),
        }
    }
}

impl<'a, 'b, T> Iterator for QueryMatches<'a, 'b, T>
where
    T: Iterator<Item = &'a Clause>,
{
    type Item = (Clause, HashMap<String, Term>);
    fn next(&mut self) -> Option<Self::Item> {
        loop {
            // Get the next clause, or return None if there isn't one
            let mut clause = self.iter.next()?.clone();
            let mut replacements = HashMap::new();

            // Make the variables unique so they don't clash with previous clauses
            replace_variables(&mut clause.0, &mut self.generator, &mut replacements);
            for body_query in &mut clause.1 {
                replace_variables(body_query, &mut self.generator, &mut replacements)
            }

            // Unify the query and the clause
            let (success, instantiations) = unify(
                self.query.clone(),
                clause.0.clone(),
                self.instantiations.clone(),
            );
            // Return the clause if unification was possible
            if success {
                return Some((clause, instantiations));
            }
        }
    }
}

impl<'a> Iterator for QueryResult<'a> {
    type Item = HashMap<String, Term>;
    /// Return the next solution (backtracking) using stack based Depth First Search (DFS).
    fn next(&mut self) -> Option<Self::Item> {
        // If the stack is empty, fail.
        while self.stack.len() > 0 {
            // Pop the next query from the stack.
            let (queries, instantiations) = self.stack.pop_back().unwrap();
        
            // If there aren't any queries, succeed.
            if queries.len() == 0 {
                return Some(instantiations);
            }

            // Cut only cuts backtracking of the current predicate, so we need to keep track of predicate boundaries.
            let cut_before = self.stack.len();
            if cut_before <= self.cut_markers.last().cloned().unwrap_or(0) {
                self.cut_markers.pop();
            }

            // Hard coded exception for cut, cut needs to be a literal atom.
            // Cutting every branch is trivial (just clear the stack). However, only the current predicate
            // is affected so the algorithm must keep track where the evaluation of a new predicate begins
            // and ends. This is done using the cut_markers vector.
            if let Term::Atom(s) = &queries[0] {
                if s == "!" {
                    // Cut all other branches until the last predicate boundary
                    self.stack.resize(self.cut_markers.pop().unwrap_or(0), (Vec::new(), HashMap::new()));
                    let new_query = queries[1..].to_vec();
                    self.stack.push_back((new_query, instantiations));
                    self.cut_markers.push(self.stack.len());
                    continue;
                }
            }

            // Iterate over the unifiable clauses in the universe.
            for m in (QueryMatches {
                iter: self.universe.clauses.iter().rev(), // We use a reverse iterator so the first rule will be on top of the stack.
                query: queries[0].clone(),
                generator: &mut self.generator,
                instantiations: &instantiations,
            }) {
                let mut new_query = (m.0).1.clone();
                new_query.extend_from_slice(&queries[1..]);
                self.stack.push_back((new_query, m.1));
            }

            // If new predicates have been pushed, add a new predicate boundary marker.
            let cut_after = self.stack.len();
            if cut_after > cut_before {
                self.cut_markers.push(cut_before);
            }
        }
        // Fail.
        None
    }
}
